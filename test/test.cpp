#include <thread>#include <pcl/io/pcd_io.h>#include <pcl/point_types.h>#include <pcl/filters/approximate_voxel_grid.h>#include <pcl/visualization/pcl_visualizer.h>#include <opencv2/core/core.hpp>#include <opencv2/highgui/highgui.hpp>#include <opencv2/opencv.hpp>using namespace std;using namespace std::chrono_literals;void test_imshow() {  cv::Mat matImg = cv::imread("../gogh.jpg", cv::IMREAD_GRAYSCALE);}int test_pcl_viewer() {  pcl::PointCloud<pcl::PointXYZ>::Ptr target_cloud(new pcl::PointCloud<pcl::PointXYZ>);  if (pcl::io::loadPCDFile<pcl::PointXYZ>("../scan.pcd", *target_cloud) == -1) {    PCL_ERROR("Couldn't read pointcloud file \n");    return (-1);  }  return 0;}bool test_automatic_breakpoint(int i) {  // usage for run_gdb_script用于测试自动化测试（打断点）  int example_i = i;  if (example_i % 2 == 0) {    return true;  } else {    return false;  }}void test_call_command() {  std::cout << "测试gdb call命令" << std::endl;}void test_eigen_pretty_printer() {  Eigen::Matrix4d pose = Eigen::Matrix4d::Identity();  pose(0, 0) = 1;}int main() {  test_imshow();  test_pcl_viewer();  for (int i = 0; i < 4; ++i) {    // todo: FunctionFinishBreakpoint跟CLion联调时暂有问题    test_automatic_breakpoint(i);  }  test_eigen_pretty_printer();  return (0);}